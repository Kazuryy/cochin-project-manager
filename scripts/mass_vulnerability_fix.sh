#!/bin/bash

# ðŸ›¡ï¸ Script de correction massive des vulnÃ©rabilitÃ©s de sÃ©curitÃ©
# Analyse et propose des corrections pour 100+ vulnÃ©rabilitÃ©s

set -e

# Couleurs pour les logs
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
NC='\033[0m' # No Color

echo -e "${BLUE}ðŸ›¡ï¸ CORRECTION MASSIVE DES VULNÃ‰RABILITÃ‰S${NC}"
echo "========================================================"

# Configuration
DOCKERHUB_USERNAME="${DOCKERHUB_USERNAME:-finnick5}"
BACKEND_IMAGE="${DOCKERHUB_USERNAME}/cochin-project-manager-backend"
FRONTEND_IMAGE="${DOCKERHUB_USERNAME}/cochin-project-manager-frontend"
TEMP_DIR="./temp_security_analysis"
VULNERABILITY_REPORT="./vulnerability_analysis_$(date +%Y%m%d_%H%M%S).json"

# CrÃ©er dossier temporaire
mkdir -p "$TEMP_DIR"

echo -e "${BLUE}ðŸ“Š Phase 1: Analyse complÃ¨te des vulnÃ©rabilitÃ©s${NC}"
echo "--------------------------------------------------------"

# Fonction pour analyser une image
analyze_image() {
    local image_name="$1"
    local output_file="$2"
    
    echo -e "${YELLOW}ðŸ” Analyse de $image_name...${NC}"
    
    # Analyser toutes les vulnÃ©rabilitÃ©s (pas seulement CRITICAL)
    trivy image \
        --format json \
        --output "$output_file" \
        --quiet \
        "$image_name" 2>/dev/null || {
        echo -e "${RED}âŒ Erreur lors de l'analyse de $image_name${NC}"
        return 1
    }
    
    echo -e "${GREEN}âœ… Analyse de $image_name terminÃ©e${NC}"
}

# Analyser nos images actuelles (locales)
echo -e "${BLUE}ðŸ³ Images Ã  analyser:${NC}"
echo "  â€¢ Backend local: cochin-backend-security-test:latest"

# Analyser l'image backend locale que nous avons buildÃ©e
if docker image inspect "cochin-backend-security-test:latest" &> /dev/null; then
    analyze_image "cochin-backend-security-test:latest" "$TEMP_DIR/backend_vulns.json"
else
    echo -e "${YELLOW}âš ï¸ Image backend locale non trouvÃ©e. Build en cours...${NC}"
    docker build -f Dockerfile.backend -t cochin-backend-security-test:latest .
    analyze_image "cochin-backend-security-test:latest" "$TEMP_DIR/backend_vulns.json"
fi

# Analyser l'image frontend si elle existe
echo -e "${YELLOW}ðŸ” Tentative d'analyse du frontend...${NC}"
if docker build -f Dockerfile.frontend -t cochin-frontend-security-test:latest . 2>/dev/null; then
    analyze_image "cochin-frontend-security-test:latest" "$TEMP_DIR/frontend_vulns.json"
else
    echo -e "${YELLOW}âš ï¸ Impossible de builder le frontend pour l'instant${NC}"
fi

echo -e "\n${BLUE}ðŸ“ˆ Phase 2: Classification et priorisation${NC}"
echo "--------------------------------------------------------"

# Fonction pour extraire et classifier les vulnÃ©rabilitÃ©s
classify_vulnerabilities() {
    local vuln_file="$1"
    local component="$2"
    
    if [ ! -f "$vuln_file" ]; then
        echo -e "${YELLOW}âš ï¸ Fichier de vulnÃ©rabilitÃ©s non trouvÃ©: $vuln_file${NC}"
        return 1
    fi
    
    echo -e "${PURPLE}ðŸ“‹ Analyse $component:${NC}"
    
    # Compter par sÃ©vÃ©ritÃ©
    local critical=$(jq -r '.Results[]?.Vulnerabilities[]? | select(.Severity == "CRITICAL") | .VulnerabilityID' "$vuln_file" 2>/dev/null | wc -l || echo "0")
    local high=$(jq -r '.Results[]?.Vulnerabilities[]? | select(.Severity == "HIGH") | .VulnerabilityID' "$vuln_file" 2>/dev/null | wc -l || echo "0")
    local medium=$(jq -r '.Results[]?.Vulnerabilities[]? | select(.Severity == "MEDIUM") | .VulnerabilityID' "$vuln_file" 2>/dev/null | wc -l || echo "0")
    local low=$(jq -r '.Results[]?.Vulnerabilities[]? | select(.Severity == "LOW") | .VulnerabilityID' "$vuln_file" 2>/dev/null | wc -l || echo "0")
    
    echo -e "  ðŸ”´ CRITICAL: $critical"
    echo -e "  ðŸŸ  HIGH: $high"  
    echo -e "  ðŸŸ¡ MEDIUM: $medium"
    echo -e "  ðŸŸ¢ LOW: $low"
    echo -e "  ðŸ“Š TOTAL: $((critical + high + medium + low))"
    
    # Top 10 des vulnÃ©rabilitÃ©s les plus critiques
    echo -e "\n  ðŸŽ¯ Top 10 vulnÃ©rabilitÃ©s critiques:"
    jq -r '.Results[]?.Vulnerabilities[]? | select(.Severity == "CRITICAL" or .Severity == "HIGH") | "    â€¢ \(.VulnerabilityID): \(.PkgName) (\(.Severity))"' "$vuln_file" 2>/dev/null | head -10 || echo "    Aucune vulnÃ©rabilitÃ© critique"
    
    echo ""
}

# Classifier les vulnÃ©rabilitÃ©s trouvÃ©es
if [ -f "$TEMP_DIR/backend_vulns.json" ]; then
    classify_vulnerabilities "$TEMP_DIR/backend_vulns.json" "BACKEND"
fi

if [ -f "$TEMP_DIR/frontend_vulns.json" ]; then
    classify_vulnerabilities "$TEMP_DIR/frontend_vulns.json" "FRONTEND"
fi

echo -e "${BLUE}ðŸ”§ Phase 3: StratÃ©gies de correction${NC}"
echo "--------------------------------------------------------"

echo -e "${PURPLE}ðŸ“ PLAN D'ACTION RECOMMANDÃ‰:${NC}"
echo ""
echo -e "${YELLOW}1. ðŸš€ CORRECTIONS IMMÃ‰DIATES (PrioritÃ© CRITIQUE):${NC}"
echo "   a) Mettre Ã  jour l'image de base Python"
echo "   b) Mettre Ã  jour les dÃ©pendances systÃ¨me"
echo "   c) Mettre Ã  jour les packages Python vulnÃ©rables"
echo ""
echo -e "${YELLOW}2. ðŸ“¦ MISE Ã€ JOUR DES IMAGES DE BASE:${NC}"
echo "   â€¢ Backend: python:3.11-slim â†’ python:3.12-slim (derniÃ¨re)"
echo "   â€¢ Frontend: node:18-alpine â†’ node:20-alpine (LTS)"
echo ""
echo -e "${YELLOW}3. ðŸ”„ MISE Ã€ JOUR DES DÃ‰PENDANCES:${NC}"
echo "   â€¢ requirements.txt â†’ audit et mise Ã  jour"
echo "   â€¢ package.json â†’ npm audit fix"
echo ""
echo -e "${YELLOW}4. ðŸ›¡ï¸ HARDENING SÃ‰CURITAIRE:${NC}"
echo "   â€¢ Multi-stage builds pour rÃ©duire la surface d'attaque"
echo "   â€¢ Images distroless quand possible"
echo "   â€¢ Utilisateur non-root"
echo ""

echo -e "${BLUE}ðŸš€ Phase 4: Application automatique des corrections${NC}"
echo "--------------------------------------------------------"

read -p "$(echo -e ${YELLOW}Voulez-vous appliquer les corrections automatiques ? [y/N]: ${NC})" -n 1 -r
echo ""

if [[ $REPLY =~ ^[Yy]$ ]]; then
    echo -e "${GREEN}ðŸ”„ Application des corrections...${NC}"
    
    # 1. Mettre Ã  jour l'image de base backend
    echo -e "${BLUE}1. Mise Ã  jour image de base backend...${NC}"
    sed -i.bak 's/FROM python:3.11-slim/FROM python:3.12-slim/' Dockerfile.backend
    
    # 2. Ajouter des mesures de sÃ©curitÃ© supplÃ©mentaires
    echo -e "${BLUE}2. Ajout de mesures de sÃ©curitÃ©...${NC}"
    
    # CrÃ©er un Dockerfile renforcÃ©
    cat > Dockerfile.backend.secure << 'EOF'
FROM python:3.12-slim

# Variables d'environnement de sÃ©curitÃ©
ENV PYTHONDONTWRITEBYTECODE=1
ENV PYTHONUNBUFFERED=1
ENV DJANGO_ENV=production
ENV PIP_NO_CACHE_DIR=1
ENV PIP_DISABLE_PIP_VERSION_CHECK=1

# CrÃ©er utilisateur non-root
RUN groupadd -r appuser && useradd -r -g appuser appuser

# Mise Ã  jour sÃ©curitaire complÃ¨te et dÃ©pendances systÃ¨me
RUN apt-get update && \
    apt-get upgrade -y && \
    apt-get install -y --no-install-recommends \
    sqlite3 \
    cron \
    && apt-get autoremove -y \
    && apt-get autoclean \
    && rm -rf /var/lib/apt/lists/* \
    && rm -rf /tmp/* \
    && rm -rf /var/tmp/* \
    && rm -rf /root/.cache

# RÃ©pertoire de travail
WORKDIR /app

# Installation des dÃ©pendances Python avec vÃ©rification de sÃ©curitÃ©
COPY backend/requirements.txt .
RUN pip install --no-cache-dir --upgrade pip setuptools wheel && \
    pip install --no-cache-dir -r requirements.txt && \
    pip install --no-cache-dir gunicorn && \
    pip check

# Copie du code avec permissions appropriÃ©es
COPY --chown=appuser:appuser backend/ .
COPY --chown=appuser:appuser init-data/ ./init-data/

# CrÃ©ation des dossiers nÃ©cessaires avec bonnes permissions
RUN mkdir -p logs backups staticfiles media db && \
    chown -R appuser:appuser /app && \
    chmod -R 755 /app

# Script de dÃ©marrage
COPY entrypoint.sh .
RUN chmod +x entrypoint.sh && chown appuser:appuser entrypoint.sh

# Basculer vers utilisateur non-root
USER appuser

# Commande par dÃ©faut
ENTRYPOINT ["./entrypoint.sh"]
EOF

    # 3. Mettre Ã  jour requirements.txt avec audit de sÃ©curitÃ©
    echo -e "${BLUE}3. Audit des dÃ©pendances Python...${NC}"
    
    # CrÃ©er un script d'audit requirements
    cat > scripts/audit_python_deps.py << 'EOF'
#!/usr/bin/env python3
import subprocess
import sys
import json

def audit_dependencies():
    """Audit des dÃ©pendances Python avec safety et pip-audit"""
    
    print("ðŸ” Audit de sÃ©curitÃ© des dÃ©pendances Python...")
    
    # Installer les outils d'audit
    subprocess.run([sys.executable, "-m", "pip", "install", "--quiet", "safety", "pip-audit"], 
                  capture_output=True)
    
    # Audit avec safety
    print("ðŸ“Š Analyse avec Safety...")
    try:
        result = subprocess.run(["safety", "check", "--json"], 
                              capture_output=True, text=True, cwd="backend")
        if result.returncode != 0:
            print("âš ï¸ VulnÃ©rabilitÃ©s dÃ©tectÃ©es avec Safety:")
            print(result.stdout)
    except:
        print("âš ï¸ Safety non disponible")
    
    # Audit avec pip-audit  
    print("ðŸ“Š Analyse avec pip-audit...")
    try:
        result = subprocess.run(["pip-audit", "--format=json"], 
                              capture_output=True, text=True, cwd="backend")
        if result.returncode != 0:
            print("âš ï¸ VulnÃ©rabilitÃ©s dÃ©tectÃ©es avec pip-audit:")
            print(result.stdout)
    except:
        print("âš ï¸ pip-audit non disponible")

if __name__ == "__main__":
    audit_dependencies()
EOF
    
    chmod +x scripts/audit_python_deps.py
    
    # 4. Mettre Ã  jour le frontend si possible
    if [ -f "frontend/package.json" ]; then
        echo -e "${BLUE}4. Audit du frontend...${NC}"
        
        # CrÃ©er Dockerfile frontend sÃ©curisÃ©
        cat > Dockerfile.frontend.secure << 'EOF'
# Multi-stage build pour rÃ©duire la surface d'attaque
FROM node:20-alpine AS builder

# Installer dumb-init pour la gestion des signaux
RUN apk add --no-cache dumb-init

# CrÃ©er utilisateur non-root
RUN addgroup -g 1001 -S nodejs && \
    adduser -S nextjs -u 1001

WORKDIR /app

# Copier les fichiers de dÃ©pendances
COPY frontend/package*.json ./
RUN npm ci --only=production && npm cache clean --force

# Copier le code source
COPY frontend/ .

# Build de production
RUN npm run build

# Stage de production minimal
FROM node:20-alpine AS runner

RUN apk add --no-cache dumb-init && \
    addgroup -g 1001 -S nodejs && \
    adduser -S nextjs -u 1001

WORKDIR /app

# Copier seulement les fichiers nÃ©cessaires
COPY --from=builder --chown=nextjs:nodejs /app/dist ./dist
COPY --from=builder --chown=nextjs:nodejs /app/node_modules ./node_modules
COPY --from=builder --chown=nextjs:nodejs /app/package.json ./package.json

USER nextjs

EXPOSE 3000

ENTRYPOINT ["dumb-init", "--"]
CMD ["npm", "start"]
EOF
    fi
    
    echo -e "${GREEN}âœ… Corrections appliquÃ©es !${NC}"
    echo ""
    echo -e "${YELLOW}ðŸ“‹ PROCHAINES Ã‰TAPES:${NC}"
    echo "1. Tester les nouveaux Dockerfiles:"
    echo "   docker build -f Dockerfile.backend.secure -t backend-secure ."
    echo ""
    echo "2. RÃ©analyser les vulnÃ©rabilitÃ©s:"
    echo "   ./scripts/check_security_vulnerabilities.sh"
    echo ""
    echo "3. Si satisfait, remplacer les Dockerfiles:"
    echo "   mv Dockerfile.backend.secure Dockerfile.backend"
    echo ""
    echo "4. Commit et dÃ©ploiement:"
    echo "   git add . && git commit -m 'fix: correction massive vulnÃ©rabilitÃ©s sÃ©curitÃ©'"
    
else
    echo -e "${YELLOW}â„¹ï¸ Corrections manuelles nÃ©cessaires${NC}"
fi

# Nettoyer
echo -e "\n${BLUE}ðŸ§¹ Nettoyage...${NC}"
rm -rf "$TEMP_DIR"

echo -e "\n${GREEN}ðŸŽ‰ Analyse terminÃ©e !${NC}"
echo "========================================================"

echo -e "${PURPLE}ðŸ“Š RÃ‰SUMÃ‰:${NC}"
echo "â€¢ Script d'analyse crÃ©Ã©"
echo "â€¢ Dockerfiles sÃ©curisÃ©s gÃ©nÃ©rÃ©s" 
echo "â€¢ Scripts d'audit crÃ©Ã©s"
echo "â€¢ Plan d'action dÃ©fini"
echo ""
echo -e "${YELLOW}ðŸ’¡ CONSEIL: ExÃ©cutez ce script rÃ©guliÃ¨rement pour maintenir la sÃ©curitÃ©${NC}" 