#!/bin/bash

# 🛡️ Script de correction massive des vulnérabilités de sécurité
# Analyse et propose des corrections pour 100+ vulnérabilités

set -e

# Couleurs pour les logs
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
NC='\033[0m' # No Color

echo -e "${BLUE}🛡️ CORRECTION MASSIVE DES VULNÉRABILITÉS${NC}"
echo "========================================================"

# Configuration
DOCKERHUB_USERNAME="${DOCKERHUB_USERNAME:-finnick5}"
BACKEND_IMAGE="${DOCKERHUB_USERNAME}/cochin-project-manager-backend"
FRONTEND_IMAGE="${DOCKERHUB_USERNAME}/cochin-project-manager-frontend"
TEMP_DIR="./temp_security_analysis"
VULNERABILITY_REPORT="./vulnerability_analysis_$(date +%Y%m%d_%H%M%S).json"

# Créer dossier temporaire
mkdir -p "$TEMP_DIR"

echo -e "${BLUE}📊 Phase 1: Analyse complète des vulnérabilités${NC}"
echo "--------------------------------------------------------"

# Fonction pour analyser une image
analyze_image() {
    local image_name="$1"
    local output_file="$2"
    
    echo -e "${YELLOW}🔍 Analyse de $image_name...${NC}"
    
    # Analyser toutes les vulnérabilités (pas seulement CRITICAL)
    trivy image \
        --format json \
        --output "$output_file" \
        --quiet \
        "$image_name" 2>/dev/null || {
        echo -e "${RED}❌ Erreur lors de l'analyse de $image_name${NC}"
        return 1
    }
    
    echo -e "${GREEN}✅ Analyse de $image_name terminée${NC}"
}

# Analyser nos images actuelles (locales)
echo -e "${BLUE}🐳 Images à analyser:${NC}"
echo "  • Backend local: cochin-backend-security-test:latest"

# Analyser l'image backend locale que nous avons buildée
if docker image inspect "cochin-backend-security-test:latest" &> /dev/null; then
    analyze_image "cochin-backend-security-test:latest" "$TEMP_DIR/backend_vulns.json"
else
    echo -e "${YELLOW}⚠️ Image backend locale non trouvée. Build en cours...${NC}"
    docker build -f Dockerfile.backend -t cochin-backend-security-test:latest .
    analyze_image "cochin-backend-security-test:latest" "$TEMP_DIR/backend_vulns.json"
fi

# Analyser l'image frontend si elle existe
echo -e "${YELLOW}🔍 Tentative d'analyse du frontend...${NC}"
if docker build -f Dockerfile.frontend -t cochin-frontend-security-test:latest . 2>/dev/null; then
    analyze_image "cochin-frontend-security-test:latest" "$TEMP_DIR/frontend_vulns.json"
else
    echo -e "${YELLOW}⚠️ Impossible de builder le frontend pour l'instant${NC}"
fi

echo -e "\n${BLUE}📈 Phase 2: Classification et priorisation${NC}"
echo "--------------------------------------------------------"

# Fonction pour extraire et classifier les vulnérabilités
classify_vulnerabilities() {
    local vuln_file="$1"
    local component="$2"
    
    if [ ! -f "$vuln_file" ]; then
        echo -e "${YELLOW}⚠️ Fichier de vulnérabilités non trouvé: $vuln_file${NC}"
        return 1
    fi
    
    echo -e "${PURPLE}📋 Analyse $component:${NC}"
    
    # Compter par sévérité
    local critical=$(jq -r '.Results[]?.Vulnerabilities[]? | select(.Severity == "CRITICAL") | .VulnerabilityID' "$vuln_file" 2>/dev/null | wc -l || echo "0")
    local high=$(jq -r '.Results[]?.Vulnerabilities[]? | select(.Severity == "HIGH") | .VulnerabilityID' "$vuln_file" 2>/dev/null | wc -l || echo "0")
    local medium=$(jq -r '.Results[]?.Vulnerabilities[]? | select(.Severity == "MEDIUM") | .VulnerabilityID' "$vuln_file" 2>/dev/null | wc -l || echo "0")
    local low=$(jq -r '.Results[]?.Vulnerabilities[]? | select(.Severity == "LOW") | .VulnerabilityID' "$vuln_file" 2>/dev/null | wc -l || echo "0")
    
    echo -e "  🔴 CRITICAL: $critical"
    echo -e "  🟠 HIGH: $high"  
    echo -e "  🟡 MEDIUM: $medium"
    echo -e "  🟢 LOW: $low"
    echo -e "  📊 TOTAL: $((critical + high + medium + low))"
    
    # Top 10 des vulnérabilités les plus critiques
    echo -e "\n  🎯 Top 10 vulnérabilités critiques:"
    jq -r '.Results[]?.Vulnerabilities[]? | select(.Severity == "CRITICAL" or .Severity == "HIGH") | "    • \(.VulnerabilityID): \(.PkgName) (\(.Severity))"' "$vuln_file" 2>/dev/null | head -10 || echo "    Aucune vulnérabilité critique"
    
    echo ""
}

# Classifier les vulnérabilités trouvées
if [ -f "$TEMP_DIR/backend_vulns.json" ]; then
    classify_vulnerabilities "$TEMP_DIR/backend_vulns.json" "BACKEND"
fi

if [ -f "$TEMP_DIR/frontend_vulns.json" ]; then
    classify_vulnerabilities "$TEMP_DIR/frontend_vulns.json" "FRONTEND"
fi

echo -e "${BLUE}🔧 Phase 3: Stratégies de correction${NC}"
echo "--------------------------------------------------------"

echo -e "${PURPLE}📝 PLAN D'ACTION RECOMMANDÉ:${NC}"
echo ""
echo -e "${YELLOW}1. 🚀 CORRECTIONS IMMÉDIATES (Priorité CRITIQUE):${NC}"
echo "   a) Mettre à jour l'image de base Python"
echo "   b) Mettre à jour les dépendances système"
echo "   c) Mettre à jour les packages Python vulnérables"
echo ""
echo -e "${YELLOW}2. 📦 MISE À JOUR DES IMAGES DE BASE:${NC}"
echo "   • Backend: python:3.11-slim → python:3.12-slim (dernière)"
echo "   • Frontend: node:18-alpine → node:20-alpine (LTS)"
echo ""
echo -e "${YELLOW}3. 🔄 MISE À JOUR DES DÉPENDANCES:${NC}"
echo "   • requirements.txt → audit et mise à jour"
echo "   • package.json → npm audit fix"
echo ""
echo -e "${YELLOW}4. 🛡️ HARDENING SÉCURITAIRE:${NC}"
echo "   • Multi-stage builds pour réduire la surface d'attaque"
echo "   • Images distroless quand possible"
echo "   • Utilisateur non-root"
echo ""

echo -e "${BLUE}🚀 Phase 4: Application automatique des corrections${NC}"
echo "--------------------------------------------------------"

read -p "$(echo -e ${YELLOW}Voulez-vous appliquer les corrections automatiques ? [y/N]: ${NC})" -n 1 -r
echo ""

if [[ $REPLY =~ ^[Yy]$ ]]; then
    echo -e "${GREEN}🔄 Application des corrections...${NC}"
    
    # 1. Mettre à jour l'image de base backend
    echo -e "${BLUE}1. Mise à jour image de base backend...${NC}"
    sed -i.bak 's/FROM python:3.11-slim/FROM python:3.12-slim/' Dockerfile.backend
    
    # 2. Ajouter des mesures de sécurité supplémentaires
    echo -e "${BLUE}2. Ajout de mesures de sécurité...${NC}"
    
    # Créer un Dockerfile renforcé
    cat > Dockerfile.backend.secure << 'EOF'
FROM python:3.12-slim

# Variables d'environnement de sécurité
ENV PYTHONDONTWRITEBYTECODE=1
ENV PYTHONUNBUFFERED=1
ENV DJANGO_ENV=production
ENV PIP_NO_CACHE_DIR=1
ENV PIP_DISABLE_PIP_VERSION_CHECK=1

# Créer utilisateur non-root
RUN groupadd -r appuser && useradd -r -g appuser appuser

# Mise à jour sécuritaire complète et dépendances système
RUN apt-get update && \
    apt-get upgrade -y && \
    apt-get install -y --no-install-recommends \
    sqlite3 \
    cron \
    && apt-get autoremove -y \
    && apt-get autoclean \
    && rm -rf /var/lib/apt/lists/* \
    && rm -rf /tmp/* \
    && rm -rf /var/tmp/* \
    && rm -rf /root/.cache

# Répertoire de travail
WORKDIR /app

# Installation des dépendances Python avec vérification de sécurité
COPY backend/requirements.txt .
RUN pip install --no-cache-dir --upgrade pip setuptools wheel && \
    pip install --no-cache-dir -r requirements.txt && \
    pip install --no-cache-dir gunicorn && \
    pip check

# Copie du code avec permissions appropriées
COPY --chown=appuser:appuser backend/ .
COPY --chown=appuser:appuser init-data/ ./init-data/

# Création des dossiers nécessaires avec bonnes permissions
RUN mkdir -p logs backups staticfiles media db && \
    chown -R appuser:appuser /app && \
    chmod -R 755 /app

# Script de démarrage
COPY entrypoint.sh .
RUN chmod +x entrypoint.sh && chown appuser:appuser entrypoint.sh

# Basculer vers utilisateur non-root
USER appuser

# Commande par défaut
ENTRYPOINT ["./entrypoint.sh"]
EOF

    # 3. Mettre à jour requirements.txt avec audit de sécurité
    echo -e "${BLUE}3. Audit des dépendances Python...${NC}"
    
    # Créer un script d'audit requirements
    cat > scripts/audit_python_deps.py << 'EOF'
#!/usr/bin/env python3
import subprocess
import sys
import json

def audit_dependencies():
    """Audit des dépendances Python avec safety et pip-audit"""
    
    print("🔍 Audit de sécurité des dépendances Python...")
    
    # Installer les outils d'audit
    subprocess.run([sys.executable, "-m", "pip", "install", "--quiet", "safety", "pip-audit"], 
                  capture_output=True)
    
    # Audit avec safety
    print("📊 Analyse avec Safety...")
    try:
        result = subprocess.run(["safety", "check", "--json"], 
                              capture_output=True, text=True, cwd="backend")
        if result.returncode != 0:
            print("⚠️ Vulnérabilités détectées avec Safety:")
            print(result.stdout)
    except:
        print("⚠️ Safety non disponible")
    
    # Audit avec pip-audit  
    print("📊 Analyse avec pip-audit...")
    try:
        result = subprocess.run(["pip-audit", "--format=json"], 
                              capture_output=True, text=True, cwd="backend")
        if result.returncode != 0:
            print("⚠️ Vulnérabilités détectées avec pip-audit:")
            print(result.stdout)
    except:
        print("⚠️ pip-audit non disponible")

if __name__ == "__main__":
    audit_dependencies()
EOF
    
    chmod +x scripts/audit_python_deps.py
    
    # 4. Mettre à jour le frontend si possible
    if [ -f "frontend/package.json" ]; then
        echo -e "${BLUE}4. Audit du frontend...${NC}"
        
        # Créer Dockerfile frontend sécurisé
        cat > Dockerfile.frontend.secure << 'EOF'
# Multi-stage build pour réduire la surface d'attaque
FROM node:20-alpine AS builder

# Installer dumb-init pour la gestion des signaux
RUN apk add --no-cache dumb-init

# Créer utilisateur non-root
RUN addgroup -g 1001 -S nodejs && \
    adduser -S nextjs -u 1001

WORKDIR /app

# Copier les fichiers de dépendances
COPY frontend/package*.json ./
RUN npm ci --only=production && npm cache clean --force

# Copier le code source
COPY frontend/ .

# Build de production
RUN npm run build

# Stage de production minimal
FROM node:20-alpine AS runner

RUN apk add --no-cache dumb-init && \
    addgroup -g 1001 -S nodejs && \
    adduser -S nextjs -u 1001

WORKDIR /app

# Copier seulement les fichiers nécessaires
COPY --from=builder --chown=nextjs:nodejs /app/dist ./dist
COPY --from=builder --chown=nextjs:nodejs /app/node_modules ./node_modules
COPY --from=builder --chown=nextjs:nodejs /app/package.json ./package.json

USER nextjs

EXPOSE 3000

ENTRYPOINT ["dumb-init", "--"]
CMD ["npm", "start"]
EOF
    fi
    
    echo -e "${GREEN}✅ Corrections appliquées !${NC}"
    echo ""
    echo -e "${YELLOW}📋 PROCHAINES ÉTAPES:${NC}"
    echo "1. Tester les nouveaux Dockerfiles:"
    echo "   docker build -f Dockerfile.backend.secure -t backend-secure ."
    echo ""
    echo "2. Réanalyser les vulnérabilités:"
    echo "   ./scripts/check_security_vulnerabilities.sh"
    echo ""
    echo "3. Si satisfait, remplacer les Dockerfiles:"
    echo "   mv Dockerfile.backend.secure Dockerfile.backend"
    echo ""
    echo "4. Commit et déploiement:"
    echo "   git add . && git commit -m 'fix: correction massive vulnérabilités sécurité'"
    
else
    echo -e "${YELLOW}ℹ️ Corrections manuelles nécessaires${NC}"
fi

# Nettoyer
echo -e "\n${BLUE}🧹 Nettoyage...${NC}"
rm -rf "$TEMP_DIR"

echo -e "\n${GREEN}🎉 Analyse terminée !${NC}"
echo "========================================================"

echo -e "${PURPLE}📊 RÉSUMÉ:${NC}"
echo "• Script d'analyse créé"
echo "• Dockerfiles sécurisés générés" 
echo "• Scripts d'audit créés"
echo "• Plan d'action défini"
echo ""
echo -e "${YELLOW}💡 CONSEIL: Exécutez ce script régulièrement pour maintenir la sécurité${NC}" 