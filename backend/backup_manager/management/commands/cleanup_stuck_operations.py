"""
Commande Django pour nettoyer les op√©rations de sauvegarde/restauration bloqu√©es
"""

import logging
from django.core.management.base import BaseCommand, CommandError
from django.utils import timezone
from datetime import timedelta
from backup_manager.models import BackupHistory, RestoreHistory

logger = logging.getLogger('backup_manager')

class Command(BaseCommand):
    help = 'Nettoie les op√©rations de sauvegarde et restauration bloqu√©es'

    def add_arguments(self, parser):
        parser.add_argument(
            '--hours',
            type=int,
            default=6,
            help='Nombre d\'heures apr√®s lesquelles une op√©ration est consid√©r√©e comme bloqu√©e'
        )
        parser.add_argument(
            '--force',
            action='store_true',
            help='Force le nettoyage sans demander de confirmation'
        )
        parser.add_argument(
            '--dry-run',
            action='store_true',
            help='Affiche les op√©rations qui seraient nettoy√©es sans les modifier'
        )
        parser.add_argument(
            '--restore-id',
            type=int,
            help='ID sp√©cifique d\'une restauration √† marquer comme √©chou√©e'
        )
        parser.add_argument(
            '--minutes',
            type=int,
            help='Nombre de minutes apr√®s lesquelles une op√©ration est consid√©r√©e comme bloqu√©e (alternative √† --hours)'
        )
        parser.add_argument(
            '--show-stats',
            action='store_true',
            help='Affiche uniquement les statistiques actuelles des op√©rations'
        )

    def handle(self, *args, **options):
        force = options['force']
        dry_run = options['dry_run']
        restore_id = options.get('restore_id')
        show_stats = options.get('show_stats')
        
        # Afficher uniquement les statistiques si demand√©
        if show_stats:
            self.show_current_stats()
            return
        
        # Traitement sp√©cifique pour un ID de restauration
        if restore_id:
            return self.handle_specific_restore(restore_id, force, dry_run)
        
        # Calcul du seuil de temps
        if options.get('minutes') is not None:
            threshold = timezone.now() - timedelta(minutes=options['minutes'])
            time_display = f"{options['minutes']} minute(s)"
        else:
            hours = options['hours']
            threshold = timezone.now() - timedelta(hours=hours)
            time_display = f"{hours} heure(s)"
        
        # Recherche des sauvegardes bloqu√©es
        stuck_backups = BackupHistory.objects.filter(
            status__in=['running', 'pending'],
            started_at__lt=threshold
        )
        
        # Recherche des restaurations bloqu√©es
        stuck_restores = RestoreHistory.objects.filter(
            status__in=['running', 'pending'],
            started_at__lt=threshold
        )
        
        total_stuck = stuck_backups.count() + stuck_restores.count()
        
        if total_stuck == 0:
            self.stdout.write(self.style.SUCCESS('‚úÖ Aucune op√©ration bloqu√©e d√©tect√©e'))
            return
        
        self.stdout.write(self.style.WARNING(
            f'üîç {stuck_backups.count()} sauvegarde(s) et {stuck_restores.count()} restauration(s) '
            f'bloqu√©es depuis plus de {time_display}'
        ))
        
        # Afficher les d√©tails des op√©rations bloqu√©es
        if stuck_backups.exists():
            self.stdout.write(self.style.WARNING('\nüìã Sauvegardes bloqu√©es:'))
            for backup in stuck_backups:
                duration = timezone.now() - backup.started_at
                hours_stuck = duration.total_seconds() / 3600
                self.stdout.write(f'  - ID: {backup.id}, Nom: {backup.backup_name}, '
                                f'Type: {backup.backup_type}, '
                                f'Bloqu√©e depuis: {hours_stuck:.1f} heures')
        
        if stuck_restores.exists():
            self.stdout.write(self.style.WARNING('\nüìã Restaurations bloqu√©es:'))
            for restore in stuck_restores:
                duration = timezone.now() - restore.started_at
                hours_stuck = duration.total_seconds() / 3600
                self.stdout.write(f'  - ID: {restore.id}, '
                                f'Source: {restore.backup_source.backup_name if restore.backup_source else "Inconnue"}, '
                                f'Bloqu√©e depuis: {hours_stuck:.1f} heures')
        
        # Demander confirmation si --force n'est pas utilis√©
        if not force and not dry_run:
            confirm = input('\n‚ö†Ô∏è Voulez-vous marquer ces op√©rations comme √©chou√©es? (oui/non): ')
            if confirm.lower() not in ['oui', 'o', 'yes', 'y']:
                self.stdout.write(self.style.WARNING('‚ùå Op√©ration annul√©e'))
                return
        
        if dry_run:
            self.stdout.write(self.style.SUCCESS(
                f'\n‚úÖ Mode simulation: {total_stuck} op√©ration(s) seraient marqu√©es comme √©chou√©es'
            ))
            return
        
        # Marquer les sauvegardes comme √©chou√©es
        for backup in stuck_backups:
            backup.status = 'failed'
            backup.completed_at = timezone.now()
            backup.error_message = f'Op√©ration automatiquement marqu√©e comme √©chou√©e apr√®s {time_display}'
            backup.save()
            logger.warning(f"Sauvegarde ID {backup.id} ({backup.backup_name}) marqu√©e comme √©chou√©e - bloqu√©e depuis {time_display}")
        
        # Marquer les restaurations comme √©chou√©es
        for restore in stuck_restores:
            restore.status = 'failed'
            restore.completed_at = timezone.now()
            restore.error_message = f'Op√©ration automatiquement marqu√©e comme √©chou√©e apr√®s {time_display}'
            restore.save()
            logger.warning(f"Restauration ID {restore.id} marqu√©e comme √©chou√©e - bloqu√©e depuis {time_display}")
        
        self.stdout.write(self.style.SUCCESS(
            f'\n‚úÖ {total_stuck} op√©ration(s) marqu√©e(s) comme √©chou√©e(s) avec succ√®s'
        ))
    
    def handle_specific_restore(self, restore_id, force, dry_run):
        """Traite une restauration sp√©cifique par ID"""
        try:
            restore = RestoreHistory.objects.get(id=restore_id)
            
            self.stdout.write(self.style.WARNING(
                f'üîç Restauration ID {restore_id} trouv√©e:'
            ))
            self.stdout.write(f'  - Nom: {restore.restore_name}')
            self.stdout.write(f'  - Statut actuel: {restore.status}')
            self.stdout.write(f'  - Source: {restore.backup_source.backup_name if restore.backup_source else "Inconnue"}')
            if restore.started_at:
                duration = timezone.now() - restore.started_at
                hours_stuck = duration.total_seconds() / 3600
                self.stdout.write(f'  - D√©marr√©e depuis: {hours_stuck:.1f} heures')
            
            if not force and not dry_run:
                confirm = input('\n‚ö†Ô∏è Voulez-vous marquer cette restauration comme √©chou√©e? (oui/non): ')
                if confirm.lower() not in ['oui', 'o', 'yes', 'y']:
                    self.stdout.write(self.style.WARNING('‚ùå Op√©ration annul√©e'))
                    return
            
            if dry_run:
                self.stdout.write(self.style.SUCCESS(
                    f'\n‚úÖ Mode simulation: La restauration ID {restore_id} serait marqu√©e comme √©chou√©e'
                ))
                return
            
            # Marquer la restauration comme √©chou√©e
            restore.status = 'failed'
            restore.completed_at = timezone.now()
            restore.error_message = f'Op√©ration manuellement marqu√©e comme √©chou√©e via commande cleanup_stuck_operations'
            restore.save()
            
            logger.warning(f"Restauration ID {restore_id} ({restore.restore_name}) manuellement marqu√©e comme √©chou√©e")
            
            self.stdout.write(self.style.SUCCESS(
                f'\n‚úÖ Restauration ID {restore_id} marqu√©e comme √©chou√©e avec succ√®s'
            ))
            
        except RestoreHistory.DoesNotExist:
            self.stdout.write(self.style.ERROR(f'‚ùå Restauration avec ID {restore_id} introuvable'))
    
    def show_current_stats(self):
        """Affiche les statistiques actuelles"""
        self.stdout.write(self.style.SUCCESS("\nüìä √âtat actuel des op√©rations:"))
        
        # Sauvegardes
        running_backups = BackupHistory.objects.filter(status='running').count()
        pending_backups = BackupHistory.objects.filter(status='pending').count()
        completed_backups = BackupHistory.objects.filter(status='completed').count()
        failed_backups = BackupHistory.objects.filter(status='failed').count()
        
        self.stdout.write(self.style.SUCCESS("üì¶ Sauvegardes:"))
        self.stdout.write(f"  - En cours: {running_backups}")
        self.stdout.write(f"  - En attente: {pending_backups}")
        self.stdout.write(f"  - Termin√©es: {completed_backups}")
        self.stdout.write(f"  - √âchou√©es: {failed_backups}")
        
        # Restaurations
        running_restores = RestoreHistory.objects.filter(status='running').count()
        pending_restores = RestoreHistory.objects.filter(status='pending').count()
        completed_restores = RestoreHistory.objects.filter(status='completed').count()
        failed_restores = RestoreHistory.objects.filter(status='failed').count()
        
        self.stdout.write(self.style.SUCCESS("\nüîÑ Restaurations:"))
        self.stdout.write(f"  - En cours: {running_restores}")
        self.stdout.write(f"  - En attente: {pending_restores}")
        self.stdout.write(f"  - Termin√©es: {completed_restores}")
        self.stdout.write(f"  - √âchou√©es: {failed_restores}")
        
        # D√©tails des restaurations en cours
        if running_restores > 0:
            self.stdout.write(self.style.WARNING("\nüìã D√©tails des restaurations en cours:"))
            for restore in RestoreHistory.objects.filter(status='running'):
                duration = timezone.now() - restore.started_at if restore.started_at else timedelta(seconds=0)
                hours_running = duration.total_seconds() / 3600
                self.stdout.write(f"  - ID: {restore.id}, Nom: {restore.restore_name}")
                self.stdout.write(f"    Source: {restore.backup_source.backup_name if restore.backup_source else 'Inconnue'}")
                self.stdout.write(f"    D√©marr√©e depuis: {hours_running:.1f} heures")
                self.stdout.write(f"    Cr√©√©e par: {restore.created_by.username}")
                self.stdout.write("") 