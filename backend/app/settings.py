"""
Django settings for app project.

Generated by 'django-admin startproject' using Django 5.2.1.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.2/ref/settings/
"""

from pathlib import Path
from dotenv import load_dotenv
import os
import secrets
import sys

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent

# Load environment variables
load_dotenv()

# Environment detection
DJANGO_ENV = os.getenv("DJANGO_ENV", "development")
IS_DEVELOPMENT = DJANGO_ENV == "development"
IS_PRODUCTION = DJANGO_ENV == "production"
IS_BUILD = DJANGO_ENV == "build"

# =============================================================================
# SECURITY SETTINGS
# =============================================================================

# Secret key validation and generation
if IS_BUILD:
    # Use a temporary secret key during build phase
    SECRET_KEY = secrets.token_urlsafe(50)
else:
    SECRET_KEY = os.getenv("SECRET_KEY")
    if not SECRET_KEY:
        if IS_DEVELOPMENT:
            # Generate a random key for development
            SECRET_KEY = secrets.token_urlsafe(50)
            print("⚠️  WARNING: Using auto-generated SECRET_KEY for development")
        else:
            raise ValueError("SECRET_KEY environment variable is required for production")

# Debug mode - never True in production
DEBUG = IS_DEVELOPMENT and os.getenv("DEBUG", "True").lower() == "true"

# Allowed hosts configuration
if IS_DEVELOPMENT:
    ALLOWED_HOSTS = ['localhost', '127.0.0.1', '0.0.0.0']
elif IS_PRODUCTION:
    allowed_hosts_str = os.getenv("ALLOWED_HOSTS", "")
    ALLOWED_HOSTS = [host.strip() for host in allowed_hosts_str.split(",") if host.strip()]
    if not ALLOWED_HOSTS:
        raise ValueError("ALLOWED_HOSTS environment variable is required for production")
else:
    ALLOWED_HOSTS = []

# =============================================================================
# APPLICATION DEFINITION
# =============================================================================

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'corsheaders',
    'crispy_forms',
    'crispy_bootstrap5',
    'crispy_tailwind',
    'rest_framework',
    'conditional_fields',
    'django_crontab',
    # Local apps
    'authentication',
    'app',
    'database',
    'backup_manager',
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'corsheaders.middleware.CorsMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

# =============================================================================
# CORS CONFIGURATION
# =============================================================================

# CORS configuration - flexible selon l'environnement
cors_origins_str = os.getenv("CORS_ALLOWED_ORIGINS", "")
if cors_origins_str:
    # Utiliser les origines définies dans les variables d'environnement
    CORS_ALLOWED_ORIGINS = [origin.strip() for origin in cors_origins_str.split(",") if origin.strip()]
else:
    # Fallback pour le développement local sans Docker
    if IS_DEVELOPMENT:
        CORS_ALLOWED_ORIGINS = [
            "http://localhost:5173",
            "http://127.0.0.1:5173",
        ]
    else:
        CORS_ALLOWED_ORIGINS = []

CORS_ALLOW_CREDENTIALS = True

# =============================================================================
# URL AND TEMPLATE CONFIGURATION
# =============================================================================

ROOT_URLCONF = 'app.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [BASE_DIR / 'templates'],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'app.wsgi.application'

# =============================================================================
# DATABASE CONFIGURATION
# =============================================================================

# Default to SQLite for development, allow override for production
if IS_PRODUCTION and os.getenv("DATABASE_URL"):
    # Production database configuration
    import dj_database_url
    DATABASES = {
        'default': dj_database_url.parse(os.getenv("DATABASE_URL"))
    }
else:
    # Development SQLite database
    DATABASES = {
        'default': {
            'ENGINE': 'django.db.backends.sqlite3',
            'NAME': BASE_DIR / 'db.sqlite3',
        }
    }

# Custom User model
AUTH_USER_MODEL = 'authentication.User'

# =============================================================================
# PASSWORD VALIDATION
# =============================================================================

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
        'OPTIONS': {
            'min_length': 12,
        }
    },
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]

# =============================================================================
# INTERNATIONALIZATION
# =============================================================================

LANGUAGE_CODE = 'fr-fr'
TIME_ZONE = 'Europe/Paris'
USE_I18N = True
USE_TZ = True

# =============================================================================
# STATIC FILES CONFIGURATION
# =============================================================================

STATIC_URL = 'static/'
STATIC_ROOT = BASE_DIR / 'staticfiles'

# =============================================================================
# FORMS CONFIGURATION
# =============================================================================

CRISPY_ALLOWED_TEMPLATE_PACKS = "tailwind"
CRISPY_TEMPLATE_PACK = "tailwind"

# =============================================================================
# SECURITY SETTINGS
# =============================================================================

# CSRF and Session configuration - flexible selon l'environnement
csrf_origins_str = os.getenv("CSRF_TRUSTED_ORIGINS", "")
if csrf_origins_str:
    # Utiliser les origines définies dans les variables d'environnement
    CSRF_TRUSTED_ORIGINS = [origin.strip() for origin in csrf_origins_str.split(",") if origin.strip()]
elif IS_DEVELOPMENT:
    # Fallback pour le développement local sans Docker
    CSRF_TRUSTED_ORIGINS = [
        "http://localhost:5173",
        "http://127.0.0.1:5173",
    ]
else:
    CSRF_TRUSTED_ORIGINS = []

# Sécurité des cookies selon l'environnement
if IS_DEVELOPMENT:
    SESSION_COOKIE_SECURE = False
    CSRF_COOKIE_SECURE = False
else:
    SESSION_COOKIE_SECURE = True
    CSRF_COOKIE_SECURE = True

# Common security settings
SESSION_COOKIE_HTTPONLY = True
CSRF_COOKIE_HTTPONLY = False  # Allow JavaScript access for CSRF token
SESSION_EXPIRE_AT_BROWSER_CLOSE = True
SESSION_COOKIE_AGE = int(os.getenv("SESSION_TIMEOUT", "3600"))  # Default: 1 hour

# Security headers
SECURE_BROWSER_XSS_FILTER = True
SECURE_CONTENT_TYPE_NOSNIFF = True
X_FRAME_OPTIONS = 'DENY'

# SSL configuration - contrôlable via variable d'environnement
FORCE_SSL = os.getenv("FORCE_SSL", "false").lower() == "true"

# Additional security settings 
if FORCE_SSL:
    SECURE_SSL_REDIRECT = True
    SECURE_HSTS_SECONDS = 31536000
    SECURE_HSTS_INCLUDE_SUBDOMAINS = True
    SECURE_HSTS_PRELOAD = True
else:
    SECURE_SSL_REDIRECT = False

# =============================================================================
# AUTHENTICATION SETTINGS
# =============================================================================

PASSWORD_RESET_TIMEOUT = int(os.getenv("PASSWORD_RESET_TIMEOUT", "3600"))
ACCOUNT_LOCKOUT_DURATION = int(os.getenv("ACCOUNT_LOCKOUT_DURATION", "15"))
MAX_LOGIN_ATTEMPTS = int(os.getenv("MAX_LOGIN_ATTEMPTS", "5"))
PASSWORD_EXPIRY_DAYS = int(os.getenv("PASSWORD_EXPIRY_DAYS", "90"))

# =============================================================================
# BACKUP CONFIGURATION
# =============================================================================

BACKUP_ROOT = BASE_DIR / 'backups'
BACKUP_STORAGE_PATH = BACKUP_ROOT / 'storage'

# Discord webhook URL pour les notifications
DISCORD_WEBHOOK_URL = os.getenv('DISCORD_WEBHOOK_URL', '')

# Backup encryption key - must be provided in production
BACKUP_ENCRYPTION_KEY = os.getenv('BACKUP_ENCRYPTION_KEY')
if not BACKUP_ENCRYPTION_KEY:
    if IS_PRODUCTION:
        raise ValueError("BACKUP_ENCRYPTION_KEY environment variable is required for production")
    else:
        # Generate a secure key for development
        BACKUP_ENCRYPTION_KEY = secrets.token_urlsafe(32)
        print("⚠️  WARNING: Using auto-generated BACKUP_ENCRYPTION_KEY for development")

# =============================================================================
# LOGGING CONFIGURATION
# =============================================================================

def setup_logging():
    """Configure logging with proper error handling and rotation."""
    logs_dir = BASE_DIR / 'logs'
    
    try:
        # Créer le dossier logs avec les bonnes permissions
        logs_dir.mkdir(exist_ok=True)
        # S'assurer que le dossier est accessible en écriture
        os.chmod(logs_dir, 0o777)
    except (PermissionError, OSError) as e:
        # Fallback to console-only logging if we can't create log directory
        print(f"⚠️  WARNING: Cannot create logs directory at {logs_dir}: {e}. Using console logging only.")
        return {
            'version': 1,
            'disable_existing_loggers': False,
            'formatters': {
                'simple': {
                    'format': '{levelname} {asctime} {name} {message}',
                    'style': '{',
                },
            },
            'handlers': {
                'console': {
                    'level': 'DEBUG' if DEBUG else 'INFO',
                    'class': 'logging.StreamHandler',
                    'formatter': 'simple',
                },
            },
            'root': {
                'handlers': ['console'],
                'level': 'DEBUG' if DEBUG else 'INFO',
            },
        }
    
    return {
        'version': 1,
        'disable_existing_loggers': False,
        'formatters': {
            'verbose': {
                'format': '{levelname} {asctime} {module} {process:d} {thread:d} {message}',
                'style': '{',
            },
            'simple': {
                'format': '{levelname} {asctime} {name} {message}',
                'style': '{',
            },
        },
        'handlers': {
            # Handler principal avec rotation par taille
            'file': {
                'level': 'INFO',
                'class': 'logging.handlers.RotatingFileHandler',
                'filename': logs_dir / 'app.log',
                'formatter': 'verbose',
                'maxBytes': 10 * 1024 * 1024,  # 10 MB par fichier
                'backupCount': 5,  # Garde 5 fichiers de sauvegarde
                'encoding': 'utf-8',
            },
            # Handler de sécurité avec rotation quotidienne
            'security': {
                'level': 'INFO',
                'class': 'logging.handlers.TimedRotatingFileHandler',
                'filename': logs_dir / 'security.log',
                'formatter': 'verbose',
                'when': 'midnight',  # Rotation à minuit
                'interval': 1,  # Chaque jour
                'backupCount': 30,  # Garde 30 jours
                'encoding': 'utf-8',
            },
            # Console pour le développement
            'console': {
                'level': 'DEBUG' if DEBUG else 'INFO',
                'class': 'logging.StreamHandler',
                'formatter': 'simple',
            },
            # Handler pour les erreurs critiques (plus petit, plus longue rétention)
            'critical': {
                'level': 'ERROR',
                'class': 'logging.handlers.RotatingFileHandler',
                'filename': logs_dir / 'critical.log',
                'formatter': 'verbose',
                'maxBytes': 5 * 1024 * 1024,  # 5 MB par fichier
                'backupCount': 10,  # Garde plus d'historique pour les erreurs
                'encoding': 'utf-8',
            },
            # Handler pour les performances et métriques
            'performance': {
                'level': 'INFO',
                'class': 'logging.handlers.TimedRotatingFileHandler',
                'filename': logs_dir / 'performance.log',
                'formatter': 'verbose',
                'when': 'midnight',
                'interval': 1,
                'backupCount': 7,  # Seulement 7 jours pour les perfs
                'encoding': 'utf-8',
            },
        },
        'loggers': {
            'django': {
                'handlers': ['file', 'console', 'critical'],
                'level': 'INFO',
                'propagate': True,
            },
            'django.security': {
                'handlers': ['security', 'critical'],
                'level': 'INFO',
                'propagate': False,
            },
            'authentication': {
                'handlers': ['file', 'security', 'critical'],
                'level': 'INFO',
                'propagate': False,
            },
            'backup_manager': {
                'handlers': ['file', 'performance'],
                'level': 'INFO',
                'propagate': False,
            },
            'database': {
                'handlers': ['file', 'performance'],
                'level': 'INFO',
                'propagate': False,
            },
        },
    }

LOGGING = setup_logging()

# =============================================================================
# DEVELOPMENT SETTINGS
# =============================================================================

if IS_DEVELOPMENT:
    INTERNAL_IPS = ['127.0.0.1']
    
    # Create necessary directories for development
    def create_dev_directories():
        """Create necessary directories for development with error handling."""
        directories = [BACKUP_ROOT, BACKUP_STORAGE_PATH]
        for directory in directories:
            try:
                directory.mkdir(parents=True, exist_ok=True)
            except PermissionError:
                print(f"⚠️  WARNING: Cannot create directory {directory}")
    
    create_dev_directories()

# =============================================================================
# CONTENT SECURITY POLICY
# =============================================================================

# CSP constants
CSP_SELF = "'self'"

CSP_DEFAULT_SRC = [CSP_SELF]
CSP_SCRIPT_SRC = [CSP_SELF, "'unsafe-eval'", "'unsafe-inline'"]
CSP_STYLE_SRC = [CSP_SELF, "'unsafe-inline'"]
CSP_IMG_SRC = [CSP_SELF, "data:", "https:"]
CSP_FONT_SRC = [CSP_SELF, "data:", "https:"]

# =============================================================================
# DJANGO REST FRAMEWORK (if needed)
# =============================================================================

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

# Print configuration summary in development
if IS_DEVELOPMENT and not IS_BUILD:
    print(f"🚀 Django started in {DJANGO_ENV} mode")
    print(f"📊 Debug mode: {DEBUG}")
    print(f"🌍 Allowed hosts: {ALLOWED_HOSTS}")
    print(f"🔐 Using {'auto-generated' if 'auto-generated' in globals().get('SECRET_KEY', '') else 'environment'} SECRET_KEY")

# =============================================================================
# CRONJOBS CONFIGURATION
# =============================================================================

# Configuration des tâches cron pour la maintenance automatique
CRONJOBS = [
    # =============================================================================
    # NOTIFICATIONS DE DEVIS (existant)
    # =============================================================================
    # Vérification quotidienne des notifications de devis à 8h du matin
    ('0 8 * * *', 'django.core.management.call_command', ['check_devis_notifications']),
    
    # =============================================================================
    # SAUVEGARDES AUTOMATIQUES
    # =============================================================================
    # Sauvegardes quotidiennes - tous les jours à 4h du matin
    ('0 4 * * *', 'django.core.management.call_command', ['run_backup', '--frequency=daily']),
    
    # Sauvegardes hebdomadaires - tous les dimanches à 5h du matin
    ('0 5 * * 0', 'django.core.management.call_command', ['run_backup', '--frequency=weekly']),
    
    # Sauvegardes mensuelles - le 1er de chaque mois à 6h du matin
    ('0 6 1 * *', 'django.core.management.call_command', ['run_backup', '--frequency=monthly']),
    
    # =============================================================================
    # MAINTENANCE SYSTÈME DE BACKUP
    # =============================================================================
    # Nettoyage automatique des fichiers temporaires - tous les jours à 2h du matin
    ('0 2 * * *', 'django.core.management.call_command', ['cleanup_temp_files', '--auto']),
    
    # Nettoyage des opérations bloquées - toutes les 6 heures
    ('0 */6 * * *', 'django.core.management.call_command', ['cleanup_stuck_operations', '--hours=6', '--force']),
    
    # Resynchronisation base de données/fichiers - tous les dimanches à 3h du matin  
    ('0 3 * * 0', 'django.core.management.call_command', ['rebuild_backup_paths', '--force']),
    
    # Nettoyage plus agressif des fichiers temporaires - tous les week-ends à 1h du matin
    ('0 1 * * 6', 'django.core.management.call_command', ['cleanup_temp_files', '--age-hours=2', '--force']),
    
    # =============================================================================
    # GESTION DES LOGS
    # =============================================================================
    # Compression des logs anciens - tous les jours à 3h du matin
    ('0 3 * * *', 'django.core.management.call_command', ['cleanup_logs', '--compress-days=7', '--force']),
    
    # Nettoyage des très anciens logs - tous les dimanches à 4h du matin
    ('0 4 * * 0', 'django.core.management.call_command', ['cleanup_logs', '--days=30', '--compress-days=7', '--force']),
]

# Configuration des tâches cron
CRONTAB_COMMAND_PREFIX = 'cd ' + str(BASE_DIR) + ' && '
CRONTAB_DJANGO_SETTINGS_MODULE = 'app.settings'
CRONTAB_LOCK_JOBS = True  # Empêche les tâches concurrentes